#!/usr/bin/env bash
# Start/stop/manage kinitro services for the current worktree
# Uses environment from .env file generated by worktree-env.sh

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Load environment if it exists
if [[ -f "$REPO_ROOT/.env" ]]; then
    set -a
    source "$REPO_ROOT/.env"
    set +a
else
    echo "Error: .env file not found. Run ./scripts/worktree-env.sh first."
    exit 1
fi

if [[ -z "${WORKTREE_NAME:-}" ]]; then
    echo "Error: WORKTREE_NAME not set in .env. Regenerate with ./scripts/worktree-env.sh"
    exit 1
fi

LOG_DIR="/tmp/kinitro_${WORKTREE_NAME}"
mkdir -p "$LOG_DIR"

usage() {
    cat << EOF
Usage: $0 [COMMAND] [OPTIONS]

Commands:
  start       Start all services (default)
  stop        Stop all services
  status      Show service status
  logs        Show service logs

Options:
  --api-only      Only manage API service
  --scheduler     Include scheduler service
  --executor      Include executor service
  --mock-miner    Include mock miner (for E2E testing)
  --all           Manage all services (default for start/stop)

Examples:
  $0                         # Start all services
  $0 start --api-only        # Start only API
  $0 start --mock-miner      # Start services with mock miner for E2E testing
  $0 stop                    # Stop all services
  $0 logs                    # Tail all logs
  $0 status                  # Show running processes
EOF
}

start_postgres() {
    echo "Starting PostgreSQL..."
    docker compose -f "$REPO_ROOT/docker-compose.yml" \
        -f "$REPO_ROOT/docker-compose.override.yml" \
        up -d postgres

    # Wait for postgres to be ready
    echo "Waiting for PostgreSQL to be ready..."
    for _ in {1..30}; do
        if PGPASSWORD="$POSTGRES_PASSWORD" psql -h localhost -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -c '\q' 2>/dev/null; then
            echo "PostgreSQL is ready"
            return 0
        fi
        sleep 1
    done
    echo "Warning: PostgreSQL may not be ready yet"
}

start_api() {
    echo "Starting API on port $API_PORT..."
    nohup uv run kinitro api \
        --database-url "$DATABASE_URL" \
        --port "$API_PORT" \
        --no-auth \
        --log-level INFO \
        &> "$LOG_DIR/api.log" &
    echo "API started (PID: $!)"
}

start_scheduler() {
    local network="${NETWORK_URL:-ws://10.0.0.3:9944}"
    local netuid="${NETUID:-2}"

    echo "Starting scheduler..."
    nohup uv run kinitro scheduler \
        --database-url "$DATABASE_URL" \
        --network "$network" \
        --netuid "$netuid" \
        --eval-interval 300 \
        --log-level INFO \
        &> "$LOG_DIR/scheduler.log" &
    echo "Scheduler started (PID: $!)"
}

start_executor() {
    local eval_images="${EVAL_IMAGES:-{}}"
    local env_families="${ENV_FAMILIES:-}"

    echo "Starting executor..."
    local cmd=(uv run kinitro executor --api-url "$API_URL" --eval-mode docker --batch-size 3 --poll-interval 5 --log-level INFO)

    if [[ -n "$eval_images" && "$eval_images" != "{}" ]]; then
        cmd+=(--eval-images "$eval_images")
    fi

    if [[ -n "$env_families" ]]; then
        cmd+=(--env-families "$env_families")
    fi

    nohup "${cmd[@]}" &> "$LOG_DIR/executor.log" &
    echo "Executor started (PID: $!)"
}

start_mock_miner() {
    local miner_port="${MOCK_MINER_PORT:-8001}"

    echo "Starting mock miner on port $miner_port..."
    nohup uv run kinitro miner mock \
        --host 0.0.0.0 \
        --port "$miner_port" \
        --random-actions \
        &> "$LOG_DIR/mock-miner.log" &
    echo "Mock miner started (PID: $!)"
    echo "  Health: http://localhost:$miner_port/health"
}

stop_services() {
    echo "Stopping services for worktree: $WORKTREE_NAME..."

    # Stop kinitro processes matching this worktree's ports/database
    pkill -f "kinitro.*--port $API_PORT" 2>/dev/null || true
    pkill -f "kinitro.*localhost:$POSTGRES_PORT" 2>/dev/null || true
    pkill -f "kinitro.*api-url.*:$API_PORT" 2>/dev/null || true
    local miner_port="${MOCK_MINER_PORT:-8001}"
    pkill -f "kinitro mock-miner.*--port $miner_port" 2>/dev/null || true

    # Stop docker containers
    docker compose -f "$REPO_ROOT/docker-compose.yml" \
        -f "$REPO_ROOT/docker-compose.override.yml" \
        down 2>/dev/null || true

    echo "Services stopped"
}

show_status() {
    echo "=== Services for worktree: $WORKTREE_NAME ==="
    echo ""
    echo "Docker containers:"
    docker ps --filter "name=kinitro.*$WORKTREE_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || echo "  None running"
    echo ""
    echo "Kinitro processes:"
    ps aux | grep -E "kinitro.*(api|scheduler|executor|mock-miner)" | grep -v grep | grep -E "($WORKTREE_NAME|$API_PORT|$DATABASE_URL|mock-miner)" || echo "  None running"
    echo ""
    echo "Log files:"
    ls -la "$LOG_DIR"/*.log 2>/dev/null || echo "  No log files"
}

show_logs() {
    echo "=== Logs for worktree: $WORKTREE_NAME ==="
    tail -f "$LOG_DIR"/*.log 2>/dev/null || echo "No log files found in $LOG_DIR"
}

# Parse command
COMMAND="${1:-start}"
shift || true

case "$COMMAND" in
    start)
        start_postgres
        sleep 2

        start_scheduler_flag=false
        start_executor_flag=false
        start_mock_miner_flag=false

        case "${1:-}" in
            --api-only)
                ;;
            --scheduler)
                start_scheduler_flag=true
                ;;
            --executor)
                start_executor_flag=true
                ;;
            --mock-miner)
                start_scheduler_flag=true
                start_executor_flag=true
                start_mock_miner_flag=true
                ;;
            --all|"")
                start_scheduler_flag=true
                start_executor_flag=true
                ;;
        esac

        start_api
        if $start_scheduler_flag || $start_executor_flag || $start_mock_miner_flag; then
            sleep 2
        fi
        if $start_scheduler_flag; then
            start_scheduler
        fi
        if $start_executor_flag; then
            start_executor
        fi
        if $start_mock_miner_flag; then
            start_mock_miner
        fi
        echo ""
        echo "Services started. Logs in: $LOG_DIR"
        ;;
    stop)
        stop_services
        ;;
    status)
        show_status
        ;;
    logs)
        show_logs
        ;;
    -h|--help|help)
        usage
        ;;
    *)
        echo "Unknown command: $COMMAND"
        usage
        exit 1
        ;;
esac
