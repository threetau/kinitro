#!/usr/bin/env bash
# Start/stop/manage kinitro services for the current worktree
# Uses environment from .env file generated by worktree-env.sh

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Load environment if it exists
if [[ -f "$REPO_ROOT/.env" ]]; then
    set -a
    source "$REPO_ROOT/.env"
    set +a
else
    echo "Error: .env file not found. Run ./scripts/worktree-env.sh first."
    exit 1
fi

LOG_DIR="/tmp/kinitro_${WORKTREE_NAME}"
mkdir -p "$LOG_DIR"

usage() {
    cat << EOF
Usage: $0 [COMMAND] [OPTIONS]

Commands:
  start       Start all services (default)
  stop        Stop all services
  status      Show service status
  logs        Show service logs

Options:
  --api-only      Only manage API service
  --scheduler     Include scheduler service
  --executor      Include executor service
  --all           Manage all services (default for start/stop)

Examples:
  $0                    # Start all services
  $0 start --api-only   # Start only API
  $0 stop               # Stop all services
  $0 logs               # Tail all logs
  $0 status             # Show running processes
EOF
}

start_postgres() {
    echo "Starting PostgreSQL..."
    docker compose -f "$REPO_ROOT/docker-compose.yml" \
        -f "$REPO_ROOT/docker-compose.override.yml" \
        up -d postgres

    # Wait for postgres to be ready
    echo "Waiting for PostgreSQL to be ready..."
    for i in {1..30}; do
        if PGPASSWORD="$POSTGRES_PASSWORD" psql -h localhost -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -c '\q' 2>/dev/null; then
            echo "PostgreSQL is ready"
            return 0
        fi
        sleep 1
    done
    echo "Warning: PostgreSQL may not be ready yet"
}

start_api() {
    echo "Starting API on port $API_PORT..."
    nohup uv run kinitro api \
        --database-url "$DATABASE_URL" \
        --port "$API_PORT" \
        --no-auth \
        --log-level INFO \
        &> "$LOG_DIR/api.log" &
    echo "API started (PID: $!)"
}

start_scheduler() {
    local network="${NETWORK_URL:-ws://10.0.0.3:9944}"
    local netuid="${NETUID:-2}"

    echo "Starting scheduler..."
    nohup uv run kinitro scheduler \
        --database-url "$DATABASE_URL" \
        --network "$network" \
        --netuid "$netuid" \
        --eval-interval 300 \
        --log-level INFO \
        &> "$LOG_DIR/scheduler.log" &
    echo "Scheduler started (PID: $!)"
}

start_executor() {
    local eval_images="${EVAL_IMAGES:-'{}'}"
    local env_families="${ENV_FAMILIES:-}"

    echo "Starting executor..."
    local cmd="uv run kinitro executor --api-url $API_URL --eval-mode docker --batch-size 3 --poll-interval 5 --log-level INFO"

    if [[ -n "$eval_images" && "$eval_images" != "'{}'" ]]; then
        cmd="$cmd --eval-images $eval_images"
    fi

    if [[ -n "$env_families" ]]; then
        cmd="$cmd --env-families $env_families"
    fi

    nohup $cmd &> "$LOG_DIR/executor.log" &
    echo "Executor started (PID: $!)"
}

stop_services() {
    echo "Stopping services for worktree: $WORKTREE_NAME..."

    # Stop kinitro processes
    pkill -f "kinitro.*$WORKTREE_NAME" 2>/dev/null || true
    pkill -f "kinitro.*port.*$API_PORT" 2>/dev/null || true
    pkill -f "kinitro.*$DATABASE_URL" 2>/dev/null || true

    # Stop docker containers
    docker compose -f "$REPO_ROOT/docker-compose.yml" \
        -f "$REPO_ROOT/docker-compose.override.yml" \
        down 2>/dev/null || true

    echo "Services stopped"
}

show_status() {
    echo "=== Services for worktree: $WORKTREE_NAME ==="
    echo ""
    echo "Docker containers:"
    docker ps --filter "name=kinitro.*$WORKTREE_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || echo "  None running"
    echo ""
    echo "Kinitro processes:"
    ps aux | grep -E "kinitro.*(api|scheduler|executor)" | grep -v grep | grep -E "($WORKTREE_NAME|$API_PORT|$DATABASE_URL)" || echo "  None running"
    echo ""
    echo "Log files:"
    ls -la "$LOG_DIR"/*.log 2>/dev/null || echo "  No log files"
}

show_logs() {
    echo "=== Logs for worktree: $WORKTREE_NAME ==="
    tail -f "$LOG_DIR"/*.log 2>/dev/null || echo "No log files found in $LOG_DIR"
}

# Parse command
COMMAND="${1:-start}"
shift || true

case "$COMMAND" in
    start)
        start_postgres
        sleep 2
        start_api
        if [[ "${1:-}" == "--all" || -z "${1:-}" ]]; then
            sleep 2
            start_scheduler
            start_executor
        fi
        echo ""
        echo "Services started. Logs in: $LOG_DIR"
        ;;
    stop)
        stop_services
        ;;
    status)
        show_status
        ;;
    logs)
        show_logs
        ;;
    -h|--help|help)
        usage
        ;;
    *)
        echo "Unknown command: $COMMAND"
        usage
        exit 1
        ;;
esac
